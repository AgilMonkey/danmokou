##See Tutorial 00 for an introduction to the basic structure of these scripts.
pattern({ })
phase(0)
	action(block, 0)
		shift-phase-to(1)
		
## This is phase #1. 
<!> type(non, `The First Bullet`)
<!> hp(20000)
<!> root(-1, 1)
phase(0)
	action(block, 0)
		## Let's fire one bullet.
		sync(fireball-red/w, <0;0:2;0:0>, s(rvelocity(cxy(0, -2))))
		## At a high level, the way this works is as follows:
			## sync : fire bullets synchronously, ie. instantaneously.
			## fireball-red/w : bullet style (fireball = base bullet style, red = color, /w = colorization method). There are three standard colorization methods: /w, /, and /b.
			## <0;0:1;0:0> : starting offset. For now, note that this is effectively a vector <1,0>.
			## s : command to create a simple bullet.
			## rvelocity: velocity-based movement function. 
			## cxy(0, -2): the vector <0,-2>.
		## We can describe this as "fire a fireball, in red/w color, starting at the position <1,0>, with velocity <0,-2>."
		## For reference, the screen is 16 units wide and 9 units high. The playable area goes from X=[-5, 5] and Y=[-4.5, 4].
		
		## Let's take a closer look at the starting offset. 
		## <0;0:1;0:0> is an V2RV2 position. A V2RV2 is composed of five numbers:
			## - Nonrotational X offset (NX)
			## - Nonrotational Y offset (NY)
			## - Rotational X offset (RX)
			## - Rotational Y offset (RY)
			## - Angle (A)
		## Let's change the angle on the previous example and see what happens.
		sync(sakura-green/, <0;0:2;0:50>, s(rvelocity(cxy(0, -2))))
		## Notice that the offset rotates by 50 degrees, and the velocity also rotates by 50 degrees.
		## There are options to prevent this from occuring. 
		## We can use "nrvelocity" to make the velocity not rotate.
		sync(fireball-blue/b, <0;0:2;0:50>, s(nrvelocity(cxy(0, -2))))
		## Only the rotational offset will rotate. If we use the nonrotational offset, the offset will not rotate.
		sync(sakura-pink/, <2;0:0;0:50>, s(rvelocity(cxy(0, -2))))
		
	## Set the shift-phase-to to `2` and press `R` in the game view to reload the script and go to the next phase.
		
<!> type(spell,  `GSRepeat, GCRepeat (2)`)
<!> hp(20000)
<!> root(0, 1)
phase(0)
	action(block, 0)
		## Now let's summon multiple bullets.

		## Parentheses and argument separators (commas) in method calls are optional, with one exception (see the tutorial on parser macros). Using newlines/ indentation within parentheses is optional.
		## To summon multiple bullets at the same time, we use the GSRepeat (Generalized Synchronous Repeat) command.
		## gsrepeat takes two arguments: an array of modifiers and an array of children. We provide only one child `s(...)`, but the language will automatically convert this to an array.
		sync(arrow-red/w, <0;0:1;0:0>, gsrepeat({
				## The gXr commands are compatible with a set of common modifiers in Danmaku/BulletManagement/GenCtxProperties.cs. Here; we use the "times" modifier (repeat X times); and the "rv2incr" modifier (increment the position after every repeat).
				times(30)
				rv2incr(<0;0:0;0:10>)
			}, s(rvelocity(cx(2))))
		)
	action(block, 1)
		## Now we'll do the same thing with an asynchronous command.
		## There are reduced ways to write V2RV2 positions.
		## - We can leave zeros blank, eg. <;:1;:>
		## - If the NX and NY components are zero, we only need to provide the last three numbers, eg. <1;0:0>
		## - If the NX, NY, RX, RY components are zero, we only need to provide the angle, eg. <15>
		## <1;:> is the same as <0;0:1;0:0>.
		async(circle-yellow/, <1;:>, gcrepeat({
				## gcrepeat = Generalized Coroutine (Asynchronous) Repeat. When using GCRepeat, GIRepeat, or GTRepeat (see next sections), you have access to time-based modifiers like "wait", "while", and "unpause". 
				## We will wait for 4 frames after each repeat. There are 120 frames per second.
				wait(4)
				times(30)
				## <10> is the same as <0;0:0;0:10>.
				rv2incr(<10>)
			}, s(rvelocity(cx(2)))
			)
		)
	## Set the shift-phase-to to `3` and press `R` in the game view to reload the script and go to the next phase.
	
	
## I have added #{ at the end of the next line. This is a comment and does not affect the parser. However; if you are using the Notepad++ styler; then this allows you to collapse the code until the closing #}
## I have also omitted some parentheses and indentation in this section. The parser effectively ignores parentheses, newlines, and indentation, so they are primarily used to keep code organized.
<!> type spell  `GIRepeat (3)` #{
<!> root 0 1
phase 0
	action block 0
		## Now we'll do the same thing with a nested asynchronous command.
		## Note that we use a wildcard * in the bullet style. If we summon this directly, the engine will throw an error. However, we can combine the wildcard with more information later.
		async(ellipse-*/w, <1;:>, girepeat({
			## girepeat = Generalized IEnumerator (Asynchronous) Repeat. The difference between this and gcrepeat is that gcrepeat always takes synchronous commands as children, whereas this can take asynchronous commands as children.
			wait	(4)
			times(30)
			rv2incr(<10>)
			## By default, GIRepeat does not wait for its children to complete before continuing. You can add the "wait-child" property to force it to wait. Turn this option on and off and press `R` to reload the script.
			##Note: you only need one hash-mark (#) to comment out a line.
			##wait-child
			
		## gcrepeat2, or gcr2, is a common shortcut. It takes five arguments: wait, times, rv2incr, any extra modifiers, and then children.
		## <> is the zero V2RV2 (<0>), so it does not change the position at all.
		## This is the same as "gcrepeat { wait(15) times(4) rv2incr(<>) ..."
		}, gcr2(15, 4, <>, {
			## We use this coloring information to complete the wildcard. For each repeat, the looper will select the next color in the array. Note that we have 4 loops and 3 colors, so on the fourth invocation, it goes back to the first color.
			color	{ pink blue green }
		} s(rvelocity(cx(2))))
		))
		## Set the shift-phase-to to `4` and press `R` in the game view to reload the script and go to the next phase. (This is the last time I'll say this!)
#}


## Now we'll use GTRepeat, the most high-level of the generalized repeaters.
<!> type spell  `GTRepeat (4)` #{
<!> root 0 1
phase 0
	action block 0
		## This is the move command. It takes two arguments: the amount of time to move for (seconds), and a path.
		## Move, as well as most command-based State Machines, are defined in Danmaku/StateMachines/ReflectedSM/ReflectedSM.cs.
		## We are using the path method "nroffset". This is the same type as "rvelocity". 
		## nroffset = NonRotational Offset. This means that the vector argument will be treated as an offset from the starting position.
		move(2, nroffset(
			## px = a vector with some function in the X position, and 0 in the Y position. PX and similar functions are defined in Danmaku/Utils/MathRepos/Parametrics.
			px(
			## sine(period, amplitude, x). You can access the raw sine function as sin. 
			## t is a function which retrieves the current lifetime of the executing context, in seconds. Since the move command executes for 2 seconds, this will range between 0 and 2. This will go through one sine curve in the 2 seconds of movement.
			sine(2, 3, t))))
	action block 1
		## gtrepeat = Generalized Task (State Machine) Repeat. 
		## While gsrepeat/gcrepeat/girepeat operate over patterning functions, gtrepeat operates any state machines.
		gtrepeat {
			## If a number is followed by `s`, it is multiplied by 120 (the number of frames in one second). This is the same as wait 120, which waits for 1 second.
			wait		1s
			times	2
			wait-child
		} 
		## Generalized repeaters can have more than one child. To do this, simply put all the children within an array.
		## Any list of values bound by { } is an array. In fact, the lines right above this use an array.
		{ ##Array open
			## Child 1
			move 2 nroffset px sine 2 3 t
			## Child 2
			async fireball-teal/ <> gcrepeat {
				wait(20)
				times(_)		## _ = infinity.
				for(2s)		## The For property limits the maximum number of frames an asynchronous repeater can run for. The repeater will run for the MINIMUM amount of time allowed. If we have times(_) and for(2s), it will run for 2 seconds, if we have times(4) and for(_); it will run 4 times.
			} gsrepeat {
				times(30)
				circle			## The "circle" property summons all iterations evenly spread within 360 degrees. 
			} s rvelocity cx 3
		} ## Array close
#}


## Now we'll use some powerful engine features to enhance the previous example.
<!> type spell  `More GTRepeat (5)` #{
<!> root 0 2
phase 0
	action block 0
		gtrepeat {
			wait		1s
			times	2
			## Be warned: while you aren't required to use wait-child in gtrepeat, you might get strange behavior when certain commands overlap themselves.
			## In this case, if we disable wait-child, then we will get two `move` commands running at the same time after 1 second, which will cause strange behavior. One entity should only run one move command at a time.
			## After you understand how the rest this example works, try disabling `wait-child`, and then try to explain the results.
			wait-child
			## Start, Preloop, and Postloop rules allow you to run basic mathematical code and bind the results to variables accessible by children.
			## By default, if you change the variables in the children, they will NOT be reflected in the parent. Every child makes copies of the variables.
			## Preloop rules are resolved on every iteration right before children are executed.
			preloop {
				## The format for a loop rule is VARIABLE OPERATOR-TYPE FUNCTION. 
				## Operators are =, +=, -=, *=, /=, //=.
				## Types are f (float), v2 (vector2), v3 (vector3), rv (v2rv2).
				## When used in the context of generalized repeaters, t is the iteration number. Here, it will be 0 the first time and 1 the second time.
				itr =f t
				## pm1/pm1mod (standing for Plus-Minus-1) is a function that returns 1 if the argument is even and -1 if the argument is odd. 
				lr  =f pm1(t)
			}
			## There are convenience methods that replicate some of this functionality. Both bindLR() as well as bindItr(target) exist. We could have removed the preloop command and written the above as:
			## bindLR
			## bindItr(itr)
		} {
			move 2 nroffset px sine 2 3 t
			async fireball-*/ <> gcrepeat {
				wait(20)
				times(_)
				for(2s)
				## Here, we use the colorf command, which takes a list of colors and an indexer. 
				## We want to use the iteration count as the index, so it summons green bullets for the first iteration and orange bullets the second.
				## To access bound variables, prefix them with `&`.
				colorf({ green orange }, &itr)
			} gsrepeat {
				times(30)
				circle
			} s 
				## This is the polar movement function. It is an offset function which takes two arguments: a radius and an angle, in degrees.
				## This is the easiest way to implement "angular velocity". 
				polar(
					## Operators are implemented as functions. This means "3 * t" is written as "* 3 t" (* is the multiplication function, aka "Mul"). 
					## Likewise, you can use or not use parentheses with them.
					*(3, t),
					## Here, we multiply the angle value by the value &lr, which is 1 in the first loop and -1 in the second loop. 
					## The bullets in the first loop will rotate counterclockwise, and in the second loop clockwise.
					## Note: if you use `bindLR` in gtrepeat, then it will also bind the variable &rl, which is -1 in the first loop and 1 in the second.
					## Try using bindLR and reversing the direction by using &rl instead of &lr. 
					* &lr * 30 t)
		}
#}



