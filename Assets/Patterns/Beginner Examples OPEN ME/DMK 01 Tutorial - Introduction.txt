
## Please make sure you are using a syntax highlighter, otherwise this tutorial will be a nightmare to read.
## The repository contains a notepadPlusPlus.xml file which can be used as a Notepad++ language definition. To update the language definition, copy it directly into `AppData/Roaming/Notepad++/userDefineLangs`. Then you can select "BDSL" from the "Language" option in the header.

## The first line of a pattern script is always pattern, followed by an array of pattern properties.
## Boss scripts will put values in this array, but we can leave it empty.
pattern({ })
## A pattern is broken up into any number of PHASEs.
## By convention, the first phase is used for setup, and has a "shift-phase-to" command used for going to the phase we want to test.
phase(0)
	action(block, 0)
		shift-phase-to(2)
		
## This is phase #1. Because we set shift-phase-to 2 in the first phase, this will be skipped.
## Phases can have properties (see Danmaku/StateMachines/SMProperties.cs), formatted as follows.
<!> type(non, `Phase 1 (Nonspell)`)
<!> hp(20000)
phase(0)
	action(block, 0)
		noop
		
<!> type(spell,  `GSRepeat, GCRepeat (2)`)
<!> hp(20000)
## The root command sets the starting position of the executor when this script is run. 
## By default, the executor will take 2 seconds to move to this position, and then the phase will start.
## However, by setting `TeleportAtPhaseStart` to true in Danmaku/Services/SaveData.cs, the executor will teleport to the position instantaneously. This is useful for testing.
<!> root(0, 1)
## The number after "phase" is the timeout. If it is zero, then there is no timeout.
phase(0)
	## The sections of a phase are executed in sequence.
	## "Action" is a group of simple commands that are executed in parallel. (Use "saction" to run simple commands in sequence.)
	## They can be either "blocking" or "nonblocking". If they are nonblocking, then the next phase section will start immediately.
	## The number after "block" is a delay timer.
	action(block, 0)
		## A sync(hronous) command executes instantaneously.
		## arrow-red/w is a bullet style (arrow = base bullet style, red = color, /w = colorization method).
		## <0;0:1;0:0> is an V2RV2 position. A V2RV2 is composed of five numbers:
			## - Nonrotational X offset (NX)
			## - Nonrotational Y offset (NY)
			## - Rotational X offset (RX)
			## - Rotational Y offset (RY)
			## - Angle (A)
		## Normally, you only need to use the last three. In this case, we will set the rotational X offset to 1, and increment the angle.
		## Note that there are reduced ways to write V2RV2s. You can omit zeros (eg. <;:1;:>), you can write them with only RX/RY/A (eg. <1;:>), or you can write them with only angle (see below for an example). You cannot put spaces within a V2RV2. Don't even try.
		## The <XXX> format constructs a constant V2RV2. We can create function-based V2RV2s by using functions in Danmaku/Utils/MathRepos/ExMRV2.cs. For example, `<0;0:1;0:0>` is the same as `rx(1)`. 
		## Parentheses and argument separators (commas) in method calls are optional, with one exception (see the tutorial on parser macros). Using newlines/ indentation within parentheses is optional.
		## gsrepeat takes two arguments: an array of modifiers and an array of children. We provide only one child `s(...)`, but the language will automatically convert this to an array.
		sync(arrow-red/w, <0;0:1;0:0>, gsrepeat({
				## gsrepeat = Generalized Synchronous Repeat. The gXr commands are compatible with a set of common modifiers in Danmaku/BulletManagement/GenCtxProperties.cs. Here; we use the "times" modifier (repeat X times); and the "rv2incr" modifier (increment the position after every repeat).
				times(30)
				## Can also be written as <10> (just the angle) or angle(10) (as a function).
				rv2incr(<0;0:0;0:10>)
			## s is the command that summons a simple bullet. There are also commands like ss (simple scalable bullet), sdd (simple bullet with custom rotation handling), pather, laser, summon (for enemies and complex objects), etc, which we will see later.
			}, s(
			## rvelocity gives a bullet rotational velocity. We see the other movement methods later.
					rvelocity(
					## cx 2 is the constant vector <2;0>. This means that the bullet will move in the direction of its V2RV2 angle with a speed of 2 units per second. The screen is 16x9 units and the play area is 10x8 units.
						cx(2)
					)
				)
			)
		)
	action(block, 1)
		## Now we'll do the same thing with an asynchronous command.
		async(circle-yellow/, <1;:>, gcrepeat({
				## gcrepeat = Generalized Coroutine (Asynchronous) Repeat. When using GCRepeat, GIRepeat, or GTRepeat (see next sections), you have access to time-based modifiers like "wait", "while", and "unpause". 
				## We will wait for 4 frames after each repeat. There are 120 frames per second.
				wait(4)
				times(30)
				rv2incr(<10>)
			}, s(rvelocity(cx(2)))
			)
		)
	## Set the shift-phase-to to `3` and press `R` in the game view to reload the script and go to the next phase.
		
## I have added #{ at the end of the next line. This is a comment and does not affect the parser. However; if you are using the Notepad++ styler; then this allows you to collapse the code until the closing #}
## I have also omitted some parentheses and indentation in this section. The parser effectively ignores parentheses, newlines, and indentation, so they are primarily used to keep code organized.
<!> type spell  `GIRepeat (3)` #{
<!> root 0 1
phase 0
	action block 0
		## Now we'll do the same thing with a nested asynchronous command.
		## Note that we use a wildcard * in the bullet style. If we summon this directly, the engine will throw an error. However, we can combine the wildcard with more information later.
		async(ellipse-*/w, <1;:>, girepeat({
			## girepeat = Generalized IEnumerator (Asynchronous) Repeat. The difference between this and gcrepeat is that gcrepeat always takes synchronous commands as children, whereas this can take asynchronous commands as children.
			wait	(4)
			times(30)
			rv2incr(<10>)
			## By default, GIRepeat does not wait for its children to complete before continuing. You can add the "wait-child" property to force it to wait. Turn this option on and off and press `R` to reload the script.
			##Note: you only need one hash-mark (#) to comment out a line.
			##wait-child
			
		## gcrepeat2, or gcr2, is a common shortcut. It takes five arguments: wait, times, rv2incr, any extra modifiers, and then children.
		## <> is the zero V2RV2, so it does not change the position at all.
		## This is the same as "gcrepeat { wait 15 times 4 rv2incr <> ..."
		}, gcr2(15, 4, <>, {
			## We use this coloring information to complete the wildcard. For each repeat, the looper will select the next color in the array. Note that we have 4 loops and 3 colors, so on the fourth invocation, it goes back to the first color.
			color	{ pink blue green }
		} s(rvelocity(cx(2))))
		))
#}


## Now we'll use GTRepeat, the most high-level of the generalized repeaters.
<!> type spell  `GTRepeat (4)` #{
<!> root 0 1
phase 0
	action block 0
		## This is the move command. It takes two arguments: the amount of time to move for (seconds), and a path.
		## Move, as well as most command-based State Machines, are defined in Danmaku/StateMachines/ReflectedSM/ReflectedSM.cs.
		## We are using the path method "nroffset". This is the same type as "rvelocity". 
		## nroffset = NonRotational Offset. This means that the vector argument will be treated as an offset from the starting position.
		move(2, nroffset(
			## px = a vector with some function in the X position, and 0 in the Y position. PX and similar functions are defined in Danmaku/Utils/MathRepos/Parametrics.
			px(
			## sine(period, amplitude, x). You can access the raw sine function as sin. 
			## t is a function which retrieves the current lifetime of the executing entity, in seconds. Since the move command executes for 2 seconds, this will range between 0 and 2. This will go through one sine curve in the 2 seconds of movement.
			sine(2, 3, t))))
	action block 1
		## gtrepeat = Generalized Task (State Machine) Repeat. 
		## While gsrepeat/gcrepeat/girepeat operate over patterning functions, gtrepeat operates any state machines.
		gtrepeat {
			## If a number is followed by `s`, it is multiplied by 120 (the number of frames in one second). This is the same as wait 120, which waits for 1 second.
			wait		1s
			times	2
			wait-child
		} 
		## Generalized repeaters can have more than one child. To do this, simply put all the children within an array.
		## Any list of values bound by { } is an array. In fact, the lines right above this use an array.
		{ ##Array open
			## Child 1
			move 2 nroffset px sine 2 3 t
			## Child 2
			async fireball-teal/ <> gcrepeat {
				wait(20)
				times(_)		## _ = infinity.
				for(2s)		## The For property limits the maximum number of frames an asynchronous repeater can run for. The repeater will run for the MINIMUM amount of time allowed. If we have times(_) and for(2s), it will run for 2 seconds, if we have times(4) and for(_); it will run 4 times.
			} gsrepeat {
				times(30)
				circle			## The "circle" property summons all iterations evenly spread within 360 degrees. 
			} s rvelocity cx 3
		} ## Array close
#}


## Now we'll use some powerful engine features to enhance the previous example.
<!> type spell  `More GTRepeat (5)` #{
<!> root 0 2
phase 0
	action block 0
		gtrepeat {
			wait		1s
			times	2
			## Be warned: while you don't need to use wait-child in gtrepeat, you might get strange behavior when certain commands overlap themselves.
			## In this case, if we disable wait-child, then we will get two `move` commands running at the same time after 1 second, which will cause strange behavior. One entity should only run one move command at a time.
			## After you understand how this example works, try disabling `wait-child`, and then try to explain the results.
			wait-child
			## Start, Preloop, and Postloop rules allow you to run basic mathematical code and bind the results to variables accessible by children.
			## By default, if you change the variables in the children, they will NOT be reflected in the parent. Every child makes copies of the variables.
			## Preloop rules are resolved on every iteration right before children are executed.
			preloop {
				## The format for a loop rule is VARIABLE OPERATOR-TYPE FUNCTION. 
				## Operators are =, +=, -=, *=, /=, //=.
				## Types are f (float), v2 (vector2), v3 (vector3), rv (v2rv2).
				## When used in the context of generalized repeaters, t is the iteration number. Here, it will be 0 the first time and 1 the second time.
				itr =f t
				## pm1/pm1mod is a function that returns 1 if the argument is even and -1 if the argument is odd. 
				lr  =f pm1(t)
			}
			## There are convenience methods that replicate some of this functionality. Both bindLR() as well as bindItr(target) exist. We could have removed the preloop command and written the above as:
			## bindLR
			## bindItr(itr)
		} {
			move 2 nroffset px sine 2 3 t
			async fireball-*/ <> gcrepeat {
				wait(20)
				times(_)
				for(2s)
				## Here, we use the colorf command, which takes a list of colors and an indexer. 
				## We want to use the iteration count as the index, so it summons green bullets for the first iteration and orange bullets the second.
				## To access bound variables, prefix them with `&`.
				colorf({ green orange }, &itr)
			} gsrepeat {
				times(30)
				circle
			} s 
				## This is the polar movement function. It is an offset function which takes two arguments: a radius and an angle, in degrees.
				## This is the easiest way to implement "angular velocity". 
				polar(
					## Operators are implemented as functions. This means "3 * t" is written as "* 3 t" (* is the multiplication function, aka "Mul"). 
					## Likewise, you can use or not use parentheses with them.
					*(3, t),
					## Here, we multiply the angle value by the value &lr, which is 1 in the first loop and -1 in the second loop. 
					## The bullets in the first loop will rotate counterclockwise, and in the second loop clockwise.
					## Note: if you use `bindLR` in gtrepeat, then it will also bind the variable &rl, which is -1 in the first loop and 1 in the second.
					## Try using bindLR and reversing the direction by using &rl instead of &lr. 
					* &lr * 30 t)
		}
#}



